# Мигание четырьмя светодиодами по очереди

Предположим, у нас есть 4 светодиода, которые мы хотим зажигать по
очереди.

## Наивный подход

Стандартный подход к решению такой задачи может выглядеть примерно так:

``` c++
int LED[4] = {...};
void setup()
{
    pinMode(LED[0], OUTPUT);
    pinMode(LED[1], OUTPUT);
    pinMode(LED[2], OUTPUT);
    pinMode(LED[3], OUTPUT);
}

void loop()
{
    for(int i = 0; i < 4; i++)
    {
        digitalWrite(LED[(i+1) % 4], HIGH);
        digitalWrite(LED[i], LOW);
        delay(1000);
    }
}
```

Такое решение работает очень хорошо, до тех пор пока все что нам нужно
делать - дискретно мигать четырьмя светодиодами по кругу. А теперь мы
хотим добавить кнопку, по нажатию на которую направление движения
огонька изменяется, при этом не теряя его положения. Как мы можем это
сделать?

Для решения подобных задач может пригодится метод с использованием
параметрически заданных функций.

## Немного теории

Параметрически заданная функция - функция, заданная в виде зависимости
*y* = *f*(*t*),
где *t* - некоторый параметр, который может меняться в произвольных
заранее заданных пределах.

## И зачем нам это?

Чем же это может помочь в задаче мигания светодиодами?

Для начала необходимо понять, а что означает мигание светодиодами по
кругу. Заметим, что это процесс периодический. А значит мы можем
рассматривать только время в рамках одного периода.

Посмотрим на то, как выглядит яркость одного из светодиодов в
зависимости от времени в рамках одного периода
(<a href="#fig:led0_time_diagram" data-reference-type="ref+label"
data-reference="fig:led0_time_diagram">1</a>):

<figure id="fig:led0_time_diagram">

<figcaption>яркость одного из светодиодов в рамках периода в зависимости
от времени</figcaption>
</figure>

Проанализировав график мы можем заметить, что яркость зависит от времени
следующей зависимостью (при *t* ∈ \[0, 4)*s*):

$$L_0(t) = 
\begin{cases}
1,& t \leq 1 \\
0,& t \> 1
\end{cases}.$$

## Пример решения

Для решения нашей задачи можно эту функцию реализовать в
микроконтроллере напрямую, однако я бы сделал одно упрощение, которое в
конкретно данном случае с моей точки зрения имеет смысл рассмотреть. Мы
зададим параметр *t* как целое число счетчик (*t* ∈ {0, 1, 2, 3}).

Функции яркости светодиодов можно в таком случае задать как:

$$L_i(t) = \begin{cases}1,& t = i\\0,& t \neq i \end{cases}.$$

Код программы, реализующей данный подход представлен ниже:

``` c++
int LED[4] = {...};
void setup()
{
    pinMode(LED[0], OUTPUT);
    pinMode(LED[1], OUTPUT);
    pinMode(LED[2], OUTPUT);
    pinMode(LED[3], OUTPUT);
}

bool Li(int t, int i)
{
    return t == 0;
}

int t = 0;

void loop()
{
    digitalWrite(LED[0], Li(t, 0));
    digitalWrite(LED[1], Li(t, 1));
    digitalWrite(LED[2], Li(t, 2));
    digitalWrite(LED[3], Li(t, 3));

    t++;
    t &= 0b11;

    delay(1000);
}
```

## Мигаем в другую сторону!

Теперь задача менять направление зажигания светодиодов сводится к просто
изменению направления изменения нашего параметра *t*. Чтобы начать
мигать в другую сторону нам достаточно начать его декрементировать,
вместо инкрементирования.

``` c++
int LED[4] = {...};
int BUTTON = ...;
void setup()
{
    pinMode(LED[0], OUTPUT);
    pinMode(LED[1], OUTPUT);
    pinMode(LED[2], OUTPUT);
    pinMode(LED[3], OUTPUT);

    pinMode(BUTTON, INPUT_PULLUP);
}

bool Li(int t, int i)
{
    return t == 0;
}

int t = 0;

void loop()
{
    bool button = !digitalRead(BUTTON);

    digitalWrite(LED[0], Li(t, 0));
    digitalWrite(LED[1], Li(t, 1));
    digitalWrite(LED[2], Li(t, 2));
    digitalWrite(LED[3], Li(t, 3));

    t += button ? -1 : 1;
    t &= 0b11;

    delay(1000);
}
```

# Мигаем плавно

А теперь предположим, что мы хотим мигать этими светодиодами плавно.

## Наивный подход

Наивное решение этой задачи не сильно отличается от решения предыдущей:

``` c++
int LED[4] = {...};
void setup()
{
    pinMode(LED[0], OUTPUT);
    pinMode(LED[1], OUTPUT);
    pinMode(LED[2], OUTPUT);
    pinMode(LED[3], OUTPUT);
}

void loop()
{
    for(int i = 0; i < 4; i++)
    {
        for(int j = 0; j < 255; j++)
        {
            analogWrite(LED[(i+1) % 4], j);
            analogWrite(LED[i], 255 - j);
            delay(4);
        }
    }
}
```

Если в предыдущем случае добавить кнопку в наивное решение еще можно
как-то умудриться, то здесь я уже даже примерно не могу придумать как
это можно сделать не меняя фундаментально структуру кода (так, чтобы мы
могли изменить направление движения в ЛЮБОЙ момент с сохранением
текущего состояния)

## Анализируем циклограмму

И, чтобы не терять время, сразу перейдем к анализу циклограммы нулевого
светодиода в рамках одного периода
(<a href="#fig:cyclic_analog" data-reference-type="ref+label"
data-reference="fig:cyclic_analog">2</a>):

<figure id="fig:cyclic_analog">

<figcaption>Циклограмма яркости нулевого светодиода</figcaption>
</figure>

Функционально эту зависимость можно представить в следующем виде:

$$L_0(t) = 
\begin{cases}
    At/T,& t \in \[0, T/4) \\
    A(T-t/T),& t \in \[T/4, T/2) \\
    0,& t \in \[T/2, T) \\
\end{cases},$$
где *A* - амплитута выходного сигнала (его максимальное значение; 256 в
нашем случае), *T* - период сигнала.

## А как же другие светодиоды?

Получить функцию яркости для других светодиодов можно с помощью
манипуляции переменной-параметром. Например функцию для светодиода 1
можно получить следующим образом:

*L*<sub>1</sub>(*t*) = *L*<sub>0</sub>((*t* − *T*/4) mod  *T*)

Аналогично можно получить функции для оставшихся светодиодов. В общем
случае можно записать:

*L*<sub>*i*</sub>(*t*) = *L*<sub>0</sub>((*t* − *i**T*/4) mod  *T*).

И выглядеть эти функции будут следующим образом
(<a href="#fig:cyclic_all" data-reference-type="ref+label"
data-reference="fig:cyclic_all">3</a>):

<figure id="fig:cyclic_all">

<figcaption>Циклограмма яркости светодиодов</figcaption>
</figure>

## Пример решения

Здесь реализуем решение сразу с кнопкой, чтобы не тратить ничье время
:).

``` c++
int LED[4] = {...};
int BUTTON = ...;
void setup()
{
    pinMode(LED[0], OUTPUT);
    pinMode(LED[1], OUTPUT);
    pinMode(LED[2], OUTPUT);
    pinMode(LED[3], OUTPUT);

    pinMode(BUTTON, INPUT_PULLUP);
}

int T = 1024;
int t = 0;
int A = 256;

int L0(int t)
{
    t %= T;
    if(t < T/4)
    {
        return A*t/T;
    }
    else if(t < T/2)
    {
        return A*T - A*t/T;
    }
    else
    {
        return 0;
    }
}

int Li(int t, int i)
{
    return L0((t + (4-i)*T/4) % T);
}

void loop()
{
    bool button = !digitalRead(BUTTON);

    analogWrite(LED[0], Li(t, 0));
    analogWrite(LED[1], Li(t, 1));
    analogWrite(LED[2], Li(t, 2));
    analogWrite(LED[3], Li(t, 3));

    t += button ? -1 : 1;
    t += (t < 0)*T;
    t %= T;

    delay(1);
}
```

# Заключение

Данный подход к решению задачи позволяет очень легко изменять вид кривых
яркости, да и не только яркости. Такой подход можно использовать в
генерации света, звука, периодических движений электроприводом и еще
много где.

В качестве домашнего задания читателю предлагается дополнить программу
для реализации следующей циклограммы
(<a href="#fig:homework" data-reference-type="ref+label"
data-reference="fig:homework">4</a>):

<figure id="fig:homework">

<figcaption>Домашнее задание (добавлены еще два светодиода; всего должно
быть 6 светодиодов)</figcaption>
</figure>